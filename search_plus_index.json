{"./":{"url":"./","title":"介绍","keywords":"","body":"swift-leetcode-book 记录刷题过程中, 整理收集来的资料和相关代码 参考 swift-algorithm-club swift-leetcode 山咏 leetcode 分类 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-06-22 18:07:38 "},"Leetcode-category.html":{"url":"Leetcode-category.html","title":"Leetcode分类","keywords":"","body":"Leetcode-category Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-06-22 22:13:21 "},"Stack/Stack.html":{"url":"Stack/Stack.html","title":"Stack","keywords":"","body":"Stack 题号 题目链接 说明 难度 Stack Stack 155 Min Stack 视频讲解 Esay 232 Implement Queue using Stacks 视频讲解 225 Implement Stack using Queues 视频讲解 150 Evaluate Reverse Polish Notation 视频讲解 Medium 71 Simplify Path 视频讲解 Medium 388 Longest Absolute File Path 视频讲解 394 Decode String 视频讲解 224 Basic Calculator 视频讲解 227 Basic Calculator II 视频讲解 385 Mini Parser 视频讲解 84 Largest Rectangle in Histogram 视频讲解 [TOC] Stack /* Last-in first-out stack (LIFO) Push and pop are O(1) operations. */ public struct Stack { fileprivate var array = [T]() public var isEmpty: Bool { return array.isEmpty } public var count: Int { return array.count } public mutating func push(_ element: T) { array.append(element) } public mutating func pop() -> T? { return array.popLast() } public var top: T? { return array.last } } extension Stack: Sequence { public func makeIterator() -> AnyIterator { var curr = self return AnyIterator { return curr.pop() } } } 155. Min Stack Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. getMin() -- Retrieve the minimum element in the stack. Example 1: Input [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"] [[],[-2],[0],[-3],[],[],[],[]] Output [null,null,null,null,-3,null,0,-2] Explanation MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // return -3 minStack.pop(); minStack.top(); // return 0 minStack.getMin(); // return -2 解法一双栈 import Foundation class MinStack { var stack: [Int] var minStack: [Int] /** initialize your data structure here. */ init() { stack = [] minStack = [] } func push(_ x: Int) { stack.append(x) if minStack.count == 0 { minStack.append(x) } else { minStack.append(min(x, minStack[minStack.count - 1])) } } func pop() { stack.removeLast() minStack.removeLast() } func top() -> Int { return stack[stack.count - 1] } func getMin() -> Int { return minStack[minStack.count - 1] } } 解法二minIndex class MinStack { /** initialize your data structure here. */ var stackArray: [Int] var minIndex: Int = 0 init() { stackArray = [Int]() } func push(_ x: Int) { stackArray.append(x) let currMin = stackArray[minIndex] if x Int { return stackArray.last ?? 0 } func getMin() -> Int { return stackArray[minIndex] } func adjustMinIndex() { minIndex = 0 guard stackArray.count > 1 else {return} var temp = stackArray[minIndex] for i in 1.. 232. Implement Queue using Stacks 150. Evaluate Reverse Polish Notation Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Note: Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation. Example 1: Input: [\"2\", \"1\", \"+\", \"3\", \"*\"] Output: 9 Explanation: ((2 + 1) * 3) = 9 Example 2: Input: [\"4\", \"13\", \"5\", \"/\", \"+\"] Output: 6 Explanation: (4 + (13 / 5)) = 6 Example 3: Input: [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"] Output: 22 Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 解法一 class ReversePolishNotation { func eval(_ tokens: [String]) -> Int { var intStack = [Int]() for token in tokens { switch token { case \"+\": guard let a = intStack.popLast(), let b = intStack.popLast() else { return -1 } intStack.append(a + b) case \"-\": guard let a = intStack.popLast(), let b = intStack.popLast() else { return -1 } intStack.append(b - a) case \"*\": guard let a = intStack.popLast(), let b = intStack.popLast() else { return -1 } intStack.append(b * a) case \"/\": guard let a = intStack.popLast(), let b = intStack.popLast() else { return -1 } intStack.append(b / a) default: guard let n = Int(token) else { return -1 } intStack.append(n) } } return intStack.last! } } 解法二 class ReversePolishNotation1 { enum Operation: String { case plus = \"+\" case minus = \"-\" case divive = \"/\" case mutiple = \"*\" func comput(_ num1: Int, _ num2: Int) -> Int { switch self { case .plus: return num1 + num2 case .minus: return num1 - num2 case .divive: return num1 / num2 case .mutiple: return num1 * num2 } } } func evalRPN(_ tokens: [String]) -> Int { var opertationNumer: [Int] = [] tokens.forEach { (token) in if let num = Int(token) { opertationNumer.append(num) } else if let operation = Operation(rawValue: token) { if let num2 = opertationNumer.popLast(), let num1 = opertationNumer.popLast() { let res = operation.comput(num1, num2) opertationNumer.append(res) } } } return opertationNumer.popLast()! } } 71. Simplify Path Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path. In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing /. Also, the canonical path must be the shortest string representing the absolute path. Example 1: Input: \"/home/\" Output: \"/home\" Explanation: Note that there is no trailing slash after the last directory name. Example 2: Input: \"/../\" Output: \"/\" Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. Example 3: Input: \"/home//foo/\" Output: \"/home/foo\" Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. Example 4: Input: \"/a/./b/../../c/\" Output: \"/c\" Example 5: Input: \"/a/../../b/../c//.//\" Output: \"/c\" Example 6: Input: \"/a//b////c/d//././/..\" Output: \"/a/b/c\" 解法 class SimplifyPath { func simplifyPath(_ paths: String) -> String { let paths = paths.components(separatedBy: \"/\") var stack = [String]() for s in paths { if s == \".\" || s == \"\"{ } else if s == \"..\" { let _ = stack.popLast() } else { stack.append(s) } } var result = \"/\" for i in 0.. 388. Longest Absolute File Path Suppose we abstract our file system by a string in the following manner: The string \"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext\" represents: dir subdir1 subdir2 file.ext The directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext. The string \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\" represents: dir subdir1 file1.ext subsubdir1 subdir2 subsubdir2 file2.ext The directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext. We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is \"dir/subdir2/subsubdir2/file2.ext\", and its length is 32 (not including the double quotes). Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0. Note: The name of a file contains at least a . and an extension. The name of a directory or sub-directory will not contain a .. Time complexity required: O(n) where n is the size of the input string. Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png. class Solution { func lengthLongestPath(_ input: String) -> Int { guard input != nil || input.count != 0 else { return 0 } //创建整形堆栈，存放各级文件长度 var stackOfLen = Stack() var strArray = input.characters.split{$0 == \"\\n\"}.map(String.init) var longesLen:Int = 0 for i in 0.. level) { stackOfLen.pop() } let tempLen:Int = item.count - level if stackOfLen.count() == 0 { stackOfLen.push(tempLen) } else { ////加1 是返回的结果带有 / 分割 let num:Int = tempLen + stackOfLen.GetLastElement() + 1 stackOfLen.push(num) } if item.contains(\".\") { longesLen = max(longesLen,stackOfLen.GetLastElement()) } } return longesLen } //获取最后一个\"\\t\"的索引整数位置 func LastIndexOf(_ item:String) -> Int { var num:Int = 0 var itemReversed:ReversedCollection = item.reversed() for i in 0.. { var items = [Element]() //入栈 //mutating 关键字修饰方法是为了能在该方法中修改 struct 或是 enum 的变量 mutating func push(_ item: Element) { items.append(item) } //出栈 mutating func pop() -> Element { return items.removeLast() } //返回堆栈中的元素个数 mutating func count() -> Int { return items.count } //获取最后一个元素 mutating func GetLastElement()->Element { return items[items.count-1] } } } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-06-23 22:11:09 "},"Leetcode-400-250.html":{"url":"Leetcode-400-250.html","title":"Leetcode 250道重点题","keywords":"","body":"Leetcode 前 400 重点 250 题 来源:https://cspiration.com/leetcodeClassification 题号 题目名称 讲解链接 1 Two Sum 视频讲解 3 Longest Substring Without Repeating Characters 视频讲解 4 Median of Two Sorted Arrays 视频讲解 5 Longest Palindromic Substring 视频讲解 7 Reverse Integer 视频讲解 8 String to Integer (atoi) 视频讲解 10 Regular Expression Matching 视频讲解 11 Container With Most Water 视频讲解 12 Integer to Roman 视频讲解 13 Roman to Integer 视频讲解 15 3Sum 视频讲解 17 Letter Combinations of a Phone Number 视频讲解 18 4Sum 视频讲解 20 Valid Parentheses 视频讲解 22 Generate Parentheses 视频讲解 23 Merge k Sorted Lists 视频讲解 26 Remove Duplicates from Sorted Array 视频讲解 27 Remove Element 视频讲解 28 Implement strStr() 视频讲解 29 Divide Two Integers 视频讲解 31 Next Permutation 视频讲解 32 Longest Valid Parentheses 视频讲解 33 Search in Rotated Sorted Array 视频讲解 34 Find First and Last Position of Element in Sorted Array 视频讲解 35 Search Insert Position 视频讲解 36 Valid Sudoku 视频讲解 37 Sudoku Solver 视频讲解 38 Count and Say 视频讲解 39 Combination Sum 视频讲解 40 Combination Sum II 视频讲解 41 First Missing Positive 视频讲解 42 Trapping Rain Water 视频讲解 43 Multiply Strings 视频讲解 44 Wildcard Matching 视频讲解 45 Jump Game II 视频讲解 46 Permutations 视频讲解 47 Permutations II 视频讲解 48 Rotate Image 视频讲解 49 Group Anagrams 视频讲解 50 Pow(x, n) 视频讲解 51 N-Queens 视频讲解 52 N-Queens II 视频讲解 53 Maximum Subarray 视频讲解 54 Spiral Matrix 视频讲解 55 Jump Game 视频讲解 56 Merge Intervals 视频讲解 57 Insert Interval 视频讲解 59 Spiral Matrix II 视频讲解 60 Permutation Sequence 视频讲解 62 Unique Paths 视频讲解 64 Minimum Path Sum 视频讲解 65 Valid Number 视频讲解 66 Plus One 视频讲解 67 Add Binary 视频讲解 68 Text Justification 视频讲解 69 Sqrt(x) 视频讲解 70 Climbing Stairs 视频讲解 71 Simplify Path 视频讲解 72 Edit Distance 视频讲解 74 Search a 2D Matrix 视频讲解 75 Sort Colors 视频讲解 76 Minimum Window Substring 视频讲解 77 Combinations 视频讲解 78 Subsets 视频讲解 79 Word Search 视频讲解 80 Remove Duplicates from Sorted Array II 视频讲解 81 Search in Rotated Sorted Array II 视频讲解 82 Remove Duplicates from Sorted List II 视频讲解 84 Largest Rectangle in Histogram 视频讲解 85 Maximal Rectangle 视频讲解 88 Merge Sorted Array 视频讲解 90 Subsets II 视频讲解 91 Decode Ways 视频讲解 96 Unique Binary Search Trees 视频讲解 98 Validate Binary Search Tree 视频讲解 101 Symmetric Tree 视频讲解 104 Maximum Depth of Binary Tree 视频讲解 108 Convert Sorted Array to Binary Search Tree 视频讲解 110 Balanced Binary Tree 视频讲解 111 Minimum Depth of Binary Tree 视频讲解 112 Path Sum 视频讲解 113 Path Sum II 视频讲解 115 Distinct Subsequences 视频讲解 116 Populating Next Right Pointers in Each Node 视频讲解 117 Populating Next Right Pointers in Each Node II 视频讲解 121 Best Time to Buy and Sell Stock 视频讲解 122 Best Time to Buy and Sell Stock II 视频讲解 123 Best Time to Buy and Sell Stock III 视频讲解 124 Binary Tree Maximum Path Sum 视频讲解 125 Valid Palindrome 视频讲解 126 Word Ladder II 视频讲解 127 Word Ladder 视频讲解 128 Longest Consecutive Sequence 视频讲解 130 Surrounded Regions 视频讲解 133 Clone Graph 视频讲解 134 Gas Station 视频讲解 138 Copy List with Random Pointer 视频讲解 139 Word Break 视频讲解 140 Word Break II 视频讲解 142 Linked List Cycle II 视频讲解 146 LRU Cache 视频讲解 149 Max Points on a Line 视频讲解 150 Evaluate Reverse Polish Notation 视频讲解 152 Maximum Product Subarray 视频讲解 153 Find Minimum in Rotated Sorted Array 视频讲解 154 Find Minimum in Rotated Sorted Array II 视频讲解 155 Min Stack 视频讲解 157 Read N Characters Given Read4 视频讲解 158 Read N Characters Given Read4 II - Call multiple times 视频讲解 161 One Edit Distance 视频讲解 162 Find Peak Element 视频讲解 163 Missing Ranges 视频讲解 168 Excel Sheet Column Title 视频讲解 171 Excel Sheet Column Number 视频讲解 173 Binary Search Tree Iterator 视频讲解 174 Dungeon Game 视频讲解 186 Reverse Words in a String II 视频讲解 188 Best Time to Buy and Sell Stock IV 视频讲解 189 Rotate Array 视频讲解 191 Number of 1 Bits 视频讲解 198 House Robber 视频讲解 200 Number of Islands 视频讲解 201 Bitwise AND of Numbers Range 视频讲解 202 Happy Number 视频讲解 204 Count Primes 视频讲解 205 Isomorphic Strings 视频讲解 207 Course Schedule 视频讲解 208 Implement Trie (Prefix Tree) 视频讲解 209 Minimum Size Subarray Sum 视频讲解 210 Course Schedule II 视频讲解 211 Add and Search Word - Data structure design 视频讲解 212 Word Search II 视频讲解 213 House Robber II 视频讲解 214 Shortest Palindrome 视频讲解 215 Kth Largest Element in an Array 视频讲解 216 Combination Sum III 视频讲解 217 Contains Duplicate 视频讲解 218 The Skyline Problem 视频讲解 219 Contains Duplicate II 视频讲解 220 Contains Duplicate III 视频讲解 221 Maximal Square 视频讲解 224 Basic Calculator 视频讲解 225 Implement Stack using Queues 视频讲解 226 Invert Binary Tree 视频讲解 227 Basic Calculator II 视频讲解 228 Summary Ranges 视频讲解 230 Kth Smallest Element in a BST 视频讲解 231 Power of Two 视频讲解 232 Implement Queue using Stacks 视频讲解 235 Lowest Common Ancestor of a Binary Search Tree 视频讲解 236 Lowest Common Ancestor of a Binary Tree 视频讲解 238 Product of Array Except Self 视频讲解 239 Sliding Window Maximum 视频讲解 240 Search a 2D Matrix II 视频讲解 241 Different Ways to Add Parentheses 视频讲解 242 Valid Anagram 视频讲解 244 Shortest Word Distance II 视频讲解 245 Shortest Word Distance III 视频讲解 249 Group Shifted Strings 视频讲解 251 Flatten 2D Vector 视频讲解 252 Meeting Rooms 视频讲解 253 Meeting Rooms II 视频讲解 254 Factor Combinations 视频讲解 256 Paint House 视频讲解 257 Binary Tree Paths 视频讲解 261 Graph Valid Tree 视频讲解 263 Ugly Number 视频讲解 264 Ugly Number II 视频讲解 265 Paint House II 视频讲解 268 Missing Number 视频讲解 269 Alien Dictionary 视频讲解 270 Closest Binary Search Tree Value 视频讲解 271 Encode and Decode Strings 视频讲解 273 Integer to English Words 视频讲解 274 H-Index 视频讲解 275 H-Index II 视频讲解 276 Paint Fence 视频讲解 277 Find the Celebrity 视频讲解 278 First Bad Version 视频讲解 279 Perfect Squares 视频讲解 280 Wiggle Sort 视频讲解 282 Expression Add Operators 视频讲解 283 Move Zeroes 视频讲解 284 Peeking Iterator 视频讲解 285 Inorder Successor in BST 视频讲解 286 Walls and Gates 视频讲解 287 Find the Duplicate Number 视频讲解 288 Unique Word Abbreviation 视频讲解 289 Game of Life 视频讲解 290 Word Pattern 视频讲解 291 Word Pattern II 视频讲解 293 Flip Game 视频讲解 294 Flip Game II 视频讲解 295 Find Median from Data Stream 视频讲解 296 Best Meeting Point 视频讲解 297 Serialize and Deserialize Binary Tree 视频讲解 298 Binary Tree Longest Consecutive Sequence 视频讲解 299 Bulls and Cows 视频讲解 300 Longest Increasing Subsequence 视频讲解 301 Remove Invalid Parentheses 视频讲解 302 Smallest Rectangle Enclosing Black Pixels 视频讲解 305 Number of Islands II 视频讲解 307 Range Sum Query - Mutable 视频讲解 308 Range Sum Query 2D - Mutable 视频讲解 309 Best Time to Buy and Sell Stock with Cooldown 视频讲解 311 Sparse Matrix Multiplication 视频讲解 312 Burst Balloons 视频讲解 314 Binary Tree Vertical Order Traversal 视频讲解 316 Remove Duplicate Letters 视频讲解 317 Shortest Distance from All Buildings 视频讲解 318 Maximum Product of Word Lengths 视频讲解 322 Coin Change 视频讲解 323 Number of Connected Components in an Undirected Graph 视频讲解 324 Wiggle Sort II 视频讲解 325 Maximum Size Subarray Sum Equals k 视频讲解 329 Longest Increasing Path in a Matrix 视频讲解 334 Increasing Triplet Subsequence 视频讲解 336 Palindrome Pairs 视频讲解 337 House Robber III 视频讲解 338 Counting Bits 视频讲解 339 Nested List Weight Sum 视频讲解 340 Longest Substring with At Most K Distinct Characters 视频讲解 341 Flatten Nested List Iterator 视频讲解 346 Moving Average from Data Stream 视频讲解 347 Top K Frequent Elements 视频讲解 348 Design Tic-Tac-Toe 视频讲解 350 Intersection of Two Arrays II 视频讲解 351 Android Unlock Patterns 视频讲解 352 Data Stream as Disjoint Intervals 视频讲解 353 Design Snake Game 视频讲解 354 Russian Doll Envelopes 视频讲解 355 Design Twitter 视频讲解 359 Logger Rate Limiter 视频讲解 361 Bomb Enemy 视频讲解 362 Design Hit Counter 视频讲解 364 Nested List Weight Sum II 视频讲解 367 Valid Perfect Square 视频讲解 374 Guess Number Higher or Lower 视频讲解 375 Guess Number Higher or Lower II 视频讲解 376 Wiggle Subsequence 视频讲解 377 Combination Sum IV 视频讲解 378 Kth Smallest Element in a Sorted Matrix 视频讲解 379 Design Phone Directory 视频讲解 380 Insert Delete GetRandom O(1) 视频讲解 381 Insert Delete GetRandom O(1) - Duplicates allowed 视频讲解 384 Shuffle an Array 视频讲解 385 Mini Parser 视频讲解 389 Find the Difference 视频讲解 394 Decode String 视频讲解 398 Random Pick Index 视频讲解 ** Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-06-22 17:47:30 "}}